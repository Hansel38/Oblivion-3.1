// dllmain.cpp : Defines the entry point for the DLL application.
#include "pch.h"
#include "ProcessThreadWatcher.h"
#include "JsonBuilder.h"
#include "NetworkClient.h"
#include "ConfigLoader.h"
#include "OverlayScanner.h"
#include "AntiDebug.h"
#include "InjectionScanner.h"
#include "DigitalSignatureValidator.h"
#include "AntiSuspend.h"
#include "HijackedThreadScanner.h"
#include "IATHookScanner.h"
#include "HWID.h"
#include "FileIntegrityChecker.h"
#include "Heartbeat.h"
#include "PeriodicScanner.h"
#include "ClientVersion.h"
#include "MemorySignatureScanner.h"
#include "KernelBridge.h"
#include "EtwHeuristics.h"
#include "CodeIntegrityScanner.h"
#include "SignaturePackManager.h"
#include <string>
#include <unordered_map>
#include <cstring>
#include <TlHelp32.h>
#include <Psapi.h>
#include <mutex>

#pragma comment(lib, "psapi.lib")

// Local RAII for HANDLE
class UniqueHandle {
public:
 UniqueHandle() noexcept : h_(nullptr) {}
 explicit UniqueHandle(HANDLE h) noexcept : h_(h) {}
 UniqueHandle(const UniqueHandle&) = delete;
 UniqueHandle& operator=(const UniqueHandle&) = delete;
 UniqueHandle(UniqueHandle&& o) noexcept : h_(o.h_) { o.h_ = nullptr; }
 UniqueHandle& operator=(UniqueHandle&& o) noexcept {
 if (this != &o) { reset(); h_ = o.h_; o.h_ = nullptr; }
 return *this;
 }
 ~UniqueHandle() { reset(); }
 void reset(HANDLE h = nullptr) noexcept { if (h_ && h_ != INVALID_HANDLE_VALUE) ::CloseHandle(h_); h_ = h; }
 HANDLE get() const noexcept { return h_; }
 explicit operator bool() const noexcept { return h_ && h_ != INVALID_HANDLE_VALUE; }
private:
 HANDLE h_;
};

// Forward declare to satisfy IntelliSense if include paths are not resolved
class AntiSuspend;

// Stud_PE export for DLL import compatibility
extern "C" __declspec(dllexport) void Garuda_Entry() {}

// Global watcher instance
ProcessThreadWatcher* g_pWatcher = nullptr;
NetworkClient* g_pNetClient = nullptr;
static HMODULE g_hModule = nullptr;
static AntiSuspend* g_pAntiSuspend = nullptr;
static Heartbeat* g_pHeartbeat = nullptr;
static PeriodicScanner* g_pPeriodic = nullptr;
static EtwHeuristics* g_pEtw = nullptr;
static SignaturePackManager* g_pSigMgr = nullptr;
static std::mutex g_cleanupMutex; // protect cleanup from races

// Runtime configuration
static ClientConfig g_cfg; // defaults will be used if file not found

// Forward decl
static void SchedulePeriodicScans();
static std::string WToUtf8(const std::wstring& ws);
static void CleanupGlobals();
extern "C" bool CE_ScanDriverService(std::wstring& outService, std::wstring& outPath); // from ServiceDriverScanner.cpp

// Inline replacement for missing HandleAccessScanner.cpp
namespace {
 // Use LONG to avoid needing NT headers for NTSTATUS
 using pfnNtQuerySystemInformation = LONG (NTAPI*)(ULONG, PVOID, ULONG, PULONG);
 typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX {
 PVOID Object;
 ULONG_PTR UniqueProcessId;
 ULONG_PTR HandleValue;
 ULONG GrantedAccess;
 USHORT CreatorBackTraceIndex;
 USHORT ObjectTypeIndex;
 ULONG HandleAttributes;
 ULONG Reserved;
 } SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;
 typedef struct _SYSTEM_HANDLE_INFORMATION_EX {
 ULONG_PTR NumberOfHandles;
 ULONG_PTR Reserved;
 SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1];
 } SYSTEM_HANDLE_INFORMATION_EX, *PSYSTEM_HANDLE_INFORMATION_EX;

 static bool GetProcessNameByPid(DWORD pid, std::wstring& name)
 {
 name.clear();
 UniqueHandle snap(CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,0));
 if (!snap) return false;
 PROCESSENTRY32W pe{}; pe.dwSize = sizeof(pe);
 if (Process32FirstW(snap.get(), &pe)) {
 do { if (pe.th32ProcessID == pid) { name = pe.szExeFile; return true; } } while (Process32NextW(snap.get(), &pe));
 }
 return false;
 }

 static bool ScanRemoteHandleToSelf(std::wstring& offenderExe, DWORD& offenderPid, std::wstring& outReason)
 {
 offenderExe.clear(); offenderPid =0; outReason.clear();
 HMODULE ntdll = GetModuleHandleW(L"ntdll.dll"); if (!ntdll) return false;
 auto NtQuerySystemInformation = reinterpret_cast<pfnNtQuerySystemInformation>(GetProcAddress(ntdll, "NtQuerySystemInformation"));
 if (!NtQuerySystemInformation) return false;
 ULONG len =1u <<20; //1MB
 std::vector<BYTE> buf; LONG st;
 for (;;) {
 buf.resize(len);
 st = NtQuerySystemInformation(0x40 /*SystemExtendedHandleInformation*/, buf.data(), len, &len);
 if (st ==0) break; // STATUS_SUCCESS
 if (st ==0xC0000004 /*STATUS_INFO_LENGTH_MISMATCH*/) { if (len > (1u<<26)) return false; continue; }
 return false;
 }
 auto shi = reinterpret_cast<PSYSTEM_HANDLE_INFORMATION_EX>(buf.data());
 DWORD self = GetCurrentProcessId();
 for (ULONG_PTR i =0; i < shi->NumberOfHandles; ++i) {
 const auto& e = shi->Handles[i];
 if ((DWORD)e.UniqueProcessId == self) continue;
 UniqueHandle hSource(OpenProcess(PROCESS_DUP_HANDLE, FALSE, (DWORD)e.UniqueProcessId));
 if (!hSource) continue;
 HANDLE hDup = nullptr; HANDLE srcHandle = (HANDLE)(ULONG_PTR)e.HandleValue;
 if (DuplicateHandle(hSource.get(), srcHandle, GetCurrentProcess(), &hDup,0, FALSE, DUPLICATE_SAME_ACCESS)) {
 UniqueHandle hold(hDup);
 DWORD target = GetProcessId(hold.get());
 if (target == self) {
 const ULONG READ =0x0010, WRITE =0x0020, OP =0x0008, CREATE_THREAD =0x0002;
 ULONG suspiciousMask = READ | WRITE | OP | CREATE_THREAD;
 if (e.GrantedAccess & suspiciousMask) {
 offenderPid = (DWORD)e.UniqueProcessId;
 GetProcessNameByPid(offenderPid, offenderExe);
 wchar_t bufReason[256]; swprintf_s(bufReason, L"Remote handle with suspicious access0x%X to our process", e.GrantedAccess);
 outReason = bufReason;
 return true;
 }
 }
 }
 }
 return false;
 }
}

static std::wstring GetDllDirectory(HMODULE hModule)
{
 wchar_t path[MAX_PATH] = {0 };
 GetModuleFileNameW(hModule, path, MAX_PATH);
 std::wstring p(path);
 size_t pos = p.find_last_of(L"\\/");
 if (pos != std::wstring::npos) p = p.substr(0, pos);
 return p;
}

static void LogIfEnabled(const wchar_t* msg)
{
 if (g_cfg.enableLogging) OutputDebugStringW(msg);
}

static void LogPerf(const wchar_t* feature, ULONGLONG ms)
{
 if (!g_cfg.enableLogging) return;
 wchar_t buf[128];
 swprintf_s(buf, L"[Oblivion] %s took %llums\n", feature, ms);
 OutputDebugStringW(buf);
}

static void ClampConfig()
{
    auto clampInt = [](int v, int lo, int hi) { if (v < lo) return lo; if (v > hi) return hi; return v; };
    auto clampDw = [](DWORD v, DWORD lo, DWORD hi) { if (v < lo) return lo; if (v > hi) return hi; return v; };

    g_cfg.closeThreshold = clampInt(g_cfg.closeThreshold, 1, 5);
    g_cfg.overlayThreshold = clampInt(g_cfg.overlayThreshold, 1, 5);
    g_cfg.antiDebugThreshold = clampInt(g_cfg.antiDebugThreshold, 1, 5);
    g_cfg.injectionThreshold = clampInt(g_cfg.injectionThreshold, 1, 5);
    g_cfg.signatureThreshold = clampInt(g_cfg.signatureThreshold, 1, 5);

    g_cfg.pollingIntervalMs = clampDw(g_cfg.pollingIntervalMs, 200, 10000);
    g_cfg.antiSuspendHeartbeatMs = clampDw(g_cfg.antiSuspendHeartbeatMs, 50, 1000);
    g_cfg.antiSuspendStallWindowMs = clampDw(g_cfg.antiSuspendStallWindowMs, 1000, 10000);
    g_cfg.antiSuspendMissesThreshold = clampInt(g_cfg.antiSuspendMissesThreshold, 1, 5);
}

static void SendDetectionJson(const DetectionResult& result, const char* subtype)
{
    if (g_pNetClient != nullptr) {
        std::string hwid = GetHWID();
        std::string jsonReport = JsonBuilder::BuildDetectionReport(result.pid, result.processName, result.reason, subtype, 1, hwid, OBLIVION_CLIENT_VERSION, result.indicatorCount);
        g_pNetClient->SendMessage(jsonReport);
    }
}

static bool ShouldSuppressDetection(const DetectionResult& result, const char* subtype)
{
    static std::unordered_map<std::string, ULONGLONG> s_lastSeen;
    static unsigned s_calls = 0;
    const ULONGLONG now = GetTickCount64();

    ULONGLONG cooldown = g_cfg.detectionCooldownMs ? g_cfg.detectionCooldownMs : 5000ULL;
    if (subtype) {
        if (strcmp(subtype, "process") == 0 && g_cfg.cooldownProcessMs) cooldown = g_cfg.cooldownProcessMs;
        else if (strcmp(subtype, "overlay") == 0 && g_cfg.cooldownOverlayMs) cooldown = g_cfg.cooldownOverlayMs;
        else if (strcmp(subtype, "antidebug") == 0 && g_cfg.cooldownAntiDebugMs) cooldown = g_cfg.cooldownAntiDebugMs;
        else if (strcmp(subtype, "injection") == 0 && g_cfg.cooldownInjectionMs) cooldown = g_cfg.cooldownInjectionMs;
        else if (strcmp(subtype, "sigcheck") == 0 && g_cfg.cooldownSigcheckMs) cooldown = g_cfg.cooldownSigcheckMs;
        else if (strcmp(subtype, "hijackedthread") == 0 && g_cfg.cooldownHijackedThreadMs) cooldown = g_cfg.cooldownHijackedThreadMs;
        else if (strcmp(subtype, "iathook") == 0 && g_cfg.cooldownIatHookMs) cooldown = g_cfg.cooldownIatHookMs;
        else if (strcmp(subtype, "integrity") == 0 && g_cfg.cooldownIntegrityMs) cooldown = g_cfg.cooldownIntegrityMs;
        else if (strcmp(subtype, "memsig") == 0 && g_cfg.cooldownMemsigMs) cooldown = g_cfg.cooldownMemsigMs;
    }

    // Cap cooldown to 1 hour to avoid overflow and compute safe horizon window (x5)
    ULONGLONG capped = (cooldown > 3600000ULL ? 3600000ULL : cooldown);
    ULONGLONG window = capped * 5ULL;
    ULONGLONG horizon = (now > window) ? (now - window) : 0ULL;

    std::string key(subtype ? subtype : "");
    key += "|";
    key += WToUtf8(result.reason);

    auto it = s_lastSeen.find(key);
    if (it != s_lastSeen.end() && (now - it->second) < cooldown) {
        return true;
    }
    s_lastSeen[key] = now;

    // Periodic pruning to cap memory: remove entries older than horizon
    if ((++s_calls & 0x3F) == 0) { // every 64 calls
        for (auto itr = s_lastSeen.begin(); itr != s_lastSeen.end(); ) {
            if (itr->second < horizon) itr = s_lastSeen.erase(itr); else ++itr;
        }
    }

    return false;
}

static BOOL CALLBACK EnumCloseWindowsProc(HWND hWnd, LPARAM lParam)
{
    DWORD targetPid = static_cast<DWORD>(lParam);
    DWORD wndPid = 0; GetWindowThreadProcessId(hWnd, &wndPid);
    if ( wndPid == targetPid && IsWindowVisible(hWnd)) {
        PostMessageW(hWnd, WM_CLOSE, 0, 0);
    }
    return TRUE;
}

static bool TryGracefulShutdownRRO(DWORD pid, DWORD timeoutMs)
{
    EnumWindows(EnumCloseWindowsProc, static_cast<LPARAM>(pid));

    UniqueHandle hProc(OpenProcess(SYNCHRONIZE, FALSE, pid));
    if (!hProc) return false;
    DWORD wait = WaitForSingleObject(hProc.get(), timeoutMs);
    return wait == WAIT_OBJECT_0;
}

static void HandleDetection(const DetectionResult& result)
{
    wchar_t messageBuffer[512];
    const wchar_t* msgFmt = g_cfg.detectionMessage.c_str();
    swprintf_s(messageBuffer, 512, msgFmt, result.processName.c_str());
    MessageBoxW(nullptr, messageBuffer, L"Oblivion AntiCheat", MB_OK | MB_ICONWARNING | MB_TOPMOST);

    UniqueHandle hSnapshot(CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0));
    if (hSnapshot) {
        PROCESSENTRY32W pe32 = { 0 };
        pe32.dwSize = sizeof(PROCESSENTRY32W);
        if (Process32FirstW(hSnapshot.get(), &pe32)) {
            do {
                std::wstring processName = pe32.szExeFile;
                std::transform(processName.begin(), processName.end(), processName.begin(), ::towlower);
                if (processName == L"rro.exe") {
                    DWORD pid = pe32.th32ProcessID;
                    bool closed = TryGracefulShutdownRRO(pid, 5000);
                    if (!closed) {
                        UniqueHandle hProcess(OpenProcess(PROCESS_TERMINATE, FALSE, pid));
                        if (hProcess) {
                            TerminateProcess(hProcess.get(), 1);
                        }
                    }
                    break;
                }
            } while (Process32NextW(hSnapshot.get(), &pe32));
        }
    }
}

static void ProcessDetection(const DetectionResult& result, const char* subtype)
{
    if (ShouldSuppressDetection(result, subtype)) {
        LogIfEnabled(L"[Oblivion] Duplicate detection suppressed\n");
        return;
    }
    SendDetectionJson(result, subtype);
    HandleDetection(result);
}

static std::vector<std::wstring> ParseWhitelistPrefixes(const std::wstring& delimited)
{
    std::vector<std::wstring> out;
    std::wstring cur;
    for (wchar_t c : delimited) {
        if (c == L';') { if (!cur.empty()) { out.push_back(cur); cur.clear(); } }
        else { cur.push_back(c); }
    }
    if (!cur.empty()) out.push_back(cur);
    return out;
}

static std::string WToUtf8(const std::wstring& ws)
{
    if (ws.empty()) return {};
    int len = WideCharToMultiByte(CP_UTF8, 0, ws.c_str(), (int)ws.size(), nullptr, 0, nullptr, nullptr);
    std::string s(len, 0);
    WideCharToMultiByte(CP_UTF8, 0, ws.c_str(), (int)ws.size(), &s[0], len, nullptr, nullptr);
    return s;
}

// Helper: identify RRO.exe by name or path (case-insensitive)
static bool IsRROExecutable(const std::wstring& s)
{
    if (s.empty()) return false;
    std::wstring t = s;
    std::transform(t.begin(), t.end(), t.begin(), ::towlower);
    if (t == L"rro.exe") return true;
    // check tail after last path separator
    size_t pos = t.find_last_of(L"\\/");
    std::wstring base = (pos == std::wstring::npos) ? t : t.substr(pos + 1);
    return base == L"rro.exe";
}

static void AntiSuspendReportBridge(const DetectionResult& dr, const char* subtype)
{
    ProcessDetection(dr, subtype);
}

// Detect common Cheat Engine artifacts in other processes (module names like vehdebug/dbk/speedhack)
static bool CheckCheatEngineArtifactsInProcess(DWORD pid, std::wstring& outProcName, std::wstring& outReason)
{
    UniqueHandle hProcSnap(CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0));
    if (!hProcSnap) return false;
    PROCESSENTRY32W pe{}; pe.dwSize = sizeof(pe);
    bool foundName = false;
    if (Process32FirstW(hProcSnap.get(), &pe)) {
        do {
            if (pe.th32ProcessID == pid) { outProcName = pe.szExeFile; foundName = true; break; }
        } while (Process32NextW(hProcSnap.get(), &pe));
    }

    // Build token list from config (semicolon-delimited)
    std::vector<std::wstring> tokens;
    {
        std::wstring s = g_cfg.ceArtifactTokens; std::wstring cur;
        for (size_t i=0;i<=s.size();++i){ wchar_t c = (i<s.size()? s[i]:L';'); if (c==L';'){ if(!cur.empty()){ tokens.push_back(cur); cur.clear(); } } else cur.push_back(c);} 
        for (auto& t : tokens) { std::transform(t.begin(), t.end(), t.begin(), ::towlower); }
        if (tokens.empty()) {
            // fallback to defaults if somehow empty
            tokens = { L"vehdebug", L"speedhack", L"dbk", L"cheatengine", L"ceserver", L"celua", L"monohelper" };
        }
    }

    UniqueHandle hModSnap(CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, pid));
    if (!hModSnap) return false;
    MODULEENTRY32W me{}; me.dwSize = sizeof(me);
    bool hit = false;
    if (Module32FirstW(hModSnap.get(), &me)) {
        do {
            std::wstring base = me.szModule;
            std::wstring path = me.szExePath;
            // lowercase
            std::transform(base.begin(), base.end(), base.begin(), ::towlower);
            std::transform(path.begin(), path.end(), path.begin(), ::towlower);
            for (const auto& tok : tokens) {
                if (!tok.empty() && (base.find(tok) != std::wstring::npos || path.find(tok) != std::wstring::npos)) {
                    // Build reason string dynamically to avoid buffer truncation
                    outReason = L"Cheat Engine artifact: module '" + std::wstring(me.szModule) + L"' in '" + std::wstring(me.szExePath) + L"'";
                    if (!foundName) outProcName = me.szModule;
                    hit = true;
                    break;
                }
            }
            if (hit) break;
        } while (Module32NextW(hModSnap.get(), &me));
    }
    return hit;
}

// Detect CE kernel driver presence by enumerating loaded device drivers for dbk-like names
static bool DetectCheatEngineDriver(std::wstring& outName)
{
    LPVOID drivers[1024]; DWORD needed = 0;
    if (!EnumDeviceDrivers(drivers, sizeof(drivers), &needed) || needed == 0) return false;
    int count = (int)(needed / sizeof(drivers[0]));
    wchar_t name[MAX_PATH];
    for (int i = 0; i < count; ++i) {
        if (GetDeviceDriverBaseNameW(drivers[i], name, MAX_PATH)) {
            std::wstring base = name; std::transform(base.begin(), base.end(), base.begin(), ::towlower);
            if (base.find(L"dbk") != std::wstring::npos || base.find(L"cedriver") != std::wstring::npos) {
                outName = name; return true;
            }
        }
    }
    return false;
}

static std::vector<std::pair<std::wstring, std::string>> ParseIntegrityItems(const std::wstring& dllDir, const std::wstring& delimited)
{
    std::vector<std::pair<std::wstring, std::string>> items;
    std::wstring cur;
    for (size_t i = 0; i <= delimited.size(); ++i) {
        wchar_t c = (i < delimited.size() ? delimited[i] : L';');
        if (c == L';') {
            if (!cur.empty()) {
                size_t eq = cur.find(L'=');
                std::wstring path = (eq == std::wstring::npos ? cur : cur.substr(0, eq));
                std::string expected;
                if (eq != std::wstring::npos) {
                    std::wstring expectW = cur.substr(eq + 1);
                    expected = WToUtf8(expectW);
                }
                if (!(path.size() >= 2 && path[1] == L':')) {
                    path = dllDir + L"\\" + path; // resolve relative to dll dir
                }
                items.emplace_back(path, expected);
            }
            cur.clear();
        }
        else {
            cur.push_back(c);
        }
    }
    return items;
}

// Periodic scanner setup
static void SchedulePeriodicScans()
{
 if (!g_cfg.enablePeriodicScans) return;
 if (g_pPeriodic) { g_pPeriodic->Stop(); delete g_pPeriodic; g_pPeriodic = nullptr; }
 try {
 g_pPeriodic = new PeriodicScanner(g_pNetClient);
 } catch (...) {
 g_pPeriodic = nullptr;
 return;
 }
 g_pPeriodic->Tick = []() -> bool {
 bool fired = false;
 ULONGLONG t0;

 // Early: system-wide CE artifact sweep (renamed or fast-renamed executables)
 {
 t0 = GetTickCount64();
 UniqueHandle hSnap(CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,0));
 if (hSnap) {
 PROCESSENTRY32W pe{}; pe.dwSize = sizeof(pe);
 if (Process32FirstW(hSnap.get(), &pe)) {
 do {
 // skip system/idle/self
 if (pe.th32ProcessID ==0 || pe.th32ProcessID ==4 || pe.th32ProcessID == GetCurrentProcessId()) continue;
 std::wstring pname, reason;
 if (CheckCheatEngineArtifactsInProcess(pe.th32ProcessID, pname, reason)) {
 DetectionResult dr{}; dr.detected = true; dr.pid = pe.th32ProcessID; dr.processName = pname; dr.reason = reason; dr.indicatorCount =5; // strong
 ProcessDetection(dr, "process"); fired = true;
 break; // one hit per tick is enough
 }
 } while (Process32NextW(hSnap.get(), &pe));
 }
 }
 LogPerf(L"Periodic.CEArtifactSweep", GetTickCount64() - t0);
 }

 // Optional: CE driver presence (dbk*)
 {
 std::wstring drvName;
 if (DetectCheatEngineDriver(drvName)) {
 DetectionResult dr{}; dr.detected = true; dr.pid = GetCurrentProcessId(); dr.processName = L"<system>"; dr.reason = L"Cheat Engine driver loaded: " + drvName; dr.indicatorCount =5;
 ProcessDetection(dr, "process"); fired = true;
 }
 }

 // New: SCM driver service presence (dbk/cedriver)
 {
 std::wstring svc, path;
 if (CE_ScanDriverService(svc, path)) {
 DetectionResult dr{}; dr.detected = true; dr.pid = GetCurrentProcessId(); dr.processName = L"<system>"; dr.reason = L"Cheat Engine driver service present: name='" + svc + L"' path='" + path + L"'"; dr.indicatorCount =5;
 ProcessDetection(dr, "process"); fired = true;
 }
 }

 // New: Remote handle access to our process (replacement for HandleAccessScanner)
 {
 std::wstring offenderExe, reason;
 DWORD offenderPid =0;
 if (ScanRemoteHandleToSelf(offenderExe, offenderPid, reason)) {
 DetectionResult dr{}; dr.detected = true; dr.pid = offenderPid; dr.processName = offenderExe.empty()? L"<unknown>" : offenderExe; dr.reason = reason; dr.indicatorCount =4;
 ProcessDetection(dr, "process"); fired = true;
 }
 }

 if (g_cfg.enableOverlayScanner) {
 t0 = GetTickCount64();
 OverlayScanner overlay; overlay.SetCloseThreshold(max(g_cfg.overlayThreshold, g_cfg.closeThreshold));
 OverlayFinding of{}; if (overlay.RunOnceScan(of)) {
 DetectionResult od{}; od.detected=true; od.pid=of.pid; od.processName = of.windowTitle.empty()? of.className : of.windowTitle; od.reason = L"Suspicious overlay detected: title='" + od.processName + L"' class='" + of.className + L"'"; od.indicatorCount = of.indicators;
 if (od.indicatorCount >= max(g_cfg.overlayThreshold, g_cfg.closeThreshold)) { ProcessDetection(od, "overlay"); fired=true; }
 }
 LogPerf(L"Periodic.OverlayScanner", GetTickCount64()-t0);
 }
 if (g_cfg.enableAntiDebug) {
 t0 = GetTickCount64();
 AntiDebug ad; ad.SetThreshold(g_cfg.antiDebugThreshold); DetectionResult dbg{}; if (ad.RunScan(dbg)) { ProcessDetection(dbg, "antidebug"); fired=true; }
 LogPerf(L"Periodic.AntiDebug", GetTickCount64()-t0);
 }
 if (g_cfg.enableInjectionScanner) {
 t0 = GetTickCount64();
 InjectionScanner inj; inj.SetThreshold(g_cfg.injectionThreshold); inj.SetWhitelistPrefixes(ParseWhitelistPrefixes(g_cfg.moduleWhitelistPrefixes)); InjectionFinding inf{}; if (inj.RunOnceScan(inf)) { DetectionResult rd{}; rd.detected=true; rd.pid=GetCurrentProcessId(); rd.processName=inf.moduleName; rd.reason=L"Suspicious module injected: " + inf.modulePath; rd.indicatorCount=inf.indicators; if (rd.indicatorCount >= g_cfg.injectionThreshold) { ProcessDetection(rd, "injection"); fired=true; } }
 LogPerf(L"Periodic.InjectionScanner", GetTickCount64()-t0);
 }
 if (g_cfg.enableSignatureValidator) {
 t0 = GetTickCount64();
 DigitalSignatureValidator dsv; dsv.SetThreshold(g_cfg.signatureThreshold); dsv.SetWhitelistPrefixes(ParseWhitelistPrefixes(g_cfg.moduleWhitelistPrefixes));
 // configure skip names from config
 dsv.SetSkipModuleNames(ParseWhitelistPrefixes(g_cfg.signatureSkipNames));
 SignatureFinding sf{}; if (dsv.RunOnceScan(sf)) {
 // Skip sigcheck for RRO.exe (hard guard) in addition to configured skip list
 if (!(IsRROExecutable(sf.moduleName) || IsRROExecutable(sf.modulePath))) {
 DetectionResult sd{}; sd.detected=true; sd.pid=GetCurrentProcessId(); sd.processName=sf.moduleName; sd.reason=L"Untrusted signature or suspicious module: " + sf.modulePath; sd.indicatorCount=sf.indicators; if (sd.indicatorCount >= g_cfg.signatureThreshold) { ProcessDetection(sd, "sigcheck"); fired=true; }
 }
 }
 LogPerf(L"Periodic.SignatureValidator", GetTickCount64()-t0);
 }
 if (g_cfg.enableHijackedThreadScanner) {
 t0 = GetTickCount64();
 HijackedThreadScanner hts; hts.SetThreshold(g_cfg.hijackedThreadThreshold); hts.SetWhitelistPrefixes(ParseWhitelistPrefixes(g_cfg.moduleWhitelistPrefixes)); HijackedThreadFinding hf{}; if (hts.RunOnceScan(hf)) { DetectionResult td{}; td.detected=true; td.pid=GetCurrentProcessId(); wchar_t addrbuf[32]; swprintf_s(addrbuf, L"0x%p", hf.startAddress); td.processName = hf.moduleName.empty()? L"<unknown>" : hf.moduleName; td.reason = std::wstring(L"Suspicious thread start: TID=") + std::to_wstring(hf.tid) + L", start=" + addrbuf + L", module=" + (hf.moduleName.empty()? L"<unknown>" : hf.moduleName); td.indicatorCount=hf.indicators; if (td.indicatorCount >= g_cfg.hijackedThreadThreshold) { ProcessDetection(td, "hijackedthread"); fired=true; } }
 LogPerf(L"Periodic.HijackedThread", GetTickCount64()-t0);
 }
 if (g_cfg.enableIATHookScanner) {
 t0 = GetTickCount64();
 IATHookScanner iat; iat.SetThreshold(g_cfg.iatHookThreshold); iat.SetWhitelistModules(ParseWhitelistPrefixes(g_cfg.moduleWhitelistPrefixes)); IATHookFinding f{}; if (iat.RunOnceScan(f)) { DetectionResult id{}; id.detected=true; id.pid=GetCurrentProcessId(); id.processName=f.moduleName.empty()? L"<unknown>" : f.moduleName; wchar_t iatbuf[32]; swprintf_s(iatbuf, L"0x%p", f.iatAddress); wchar_t tgtbuf[32]; swprintf_s(tgtbuf, L"0x%p", f.targetAddress); id.reason = std::wstring(L"IAT hook: module=") + id.processName + L", import='" + std::wstring(f.importName.begin(), f.importName.end()) + L"', iat=" + iatbuf + L", target=" + tgtbuf + L", targetModule=" + (f.targetModule.empty()? L"<unknown>" : f.targetModule); id.indicatorCount=f.indicators; if (id.indicatorCount >= g_cfg.iatHookThreshold) { ProcessDetection(id, "iathook"); fired=true; } }
 LogPerf(L"Periodic.IATHook", GetTickCount64()-t0);
 }
 if (g_cfg.enableFileIntegrityCheck && !g_cfg.integrityItems.empty()) {
 t0 = GetTickCount64();
 auto items = ParseIntegrityItems(GetDllDirectory(g_hModule), g_cfg.integrityItems); FileIntegrityChecker fic; fic.SetItems(items); IntegrityFinding fi{}; if (fic.RunOnceScan(fi)) { DetectionResult ir{}; ir.detected=true; ir.pid=GetCurrentProcessId(); ir.processName=fi.path; std::wstring exp = fi.expectedHex.empty()? L"<none>" : std::wstring(fi.expectedHex.begin(), fi.expectedHex.end()); std::wstring act = fi.actualHex.empty()? L"<none>" : std::wstring(fi.actualHex.begin(), fi.actualHex.end()); ir.reason = L"Integrity mismatch: path='" + fi.path + L"' expected=" + exp + L" actual=" + act; ir.indicatorCount=fi.indicators; if (ir.indicatorCount >= 1) { ProcessDetection(ir, "integrity"); fired=true; } }
 LogPerf(L"Periodic.FileIntegrity", GetTickCount64()-t0);
 }
 if (g_cfg.enableMemorySignatureScanner && !g_cfg.memorySignatures.empty()) {
 t0 = GetTickCount64();
 std::vector<MemSigPattern> pats;
 std::wstring s = g_cfg.memorySignatures; std::wstring cur;
 auto flush = [&](const std::wstring& entry) {
 if (entry.empty()) return;
 size_t eq = entry.find(L'='); if (eq == std::wstring::npos) return;
 std::wstring nameW(entry.begin(), entry.begin() + eq);
 // extract optional weight suffix in name: name@3
 int weight = 1;
 size_t at = nameW.find(L'@');
 if (at != std::wstring::npos) {
 std::wstring wstr = nameW.substr(at + 1);
 try { weight = std::stoi(wstr); } catch(...) { weight = 1; }
 nameW = nameW.substr(0, at);
 }
 std::string name = WToUtf8(nameW);
 std::wstring bytesStr = entry.substr(eq + 1);
 std::vector<unsigned char> bytes; std::vector<unsigned char> mask;
 std::wstring token;
 auto hexNibble = [](wchar_t c) -> int {
 if (c >= L'0' && c <= L'9') return c - L'0';
 if (c >= L'a' && c <= L'f') return 10 + (c - L'a');
 if (c >= L'A' && c <= L'F') return 10 + (c - L'A');
 return -1;
 };
 auto pushTok = [&](){
 if (token.empty()) return;
 if (token.size() ==2) {
 wchar_t a = token[0];
 wchar_t b = token[1];
 if (a == L'?' && b == L'?') {
 bytes.push_back(0);
 mask.push_back(0x00);
 } else if (a == L'?') {
 int lb = hexNibble(b);
 if (lb >=0) {
 bytes.push_back((unsigned char)lb);
 mask.push_back(0x0F);
 }
 } else if (b == L'?') {
 int hb = hexNibble(a);
 if (hb >=0) {
 bytes.push_back((unsigned char)(hb <<4));
 mask.push_back(0xF0);
 }
 } else {
 int hb = hexNibble(a);
 int lb = hexNibble(b);
 if (hb >=0 && lb >=0) {
 bytes.push_back((unsigned char)((hb <<4) | lb));
 mask.push_back(0xFF);
 }
 }
 } else if (token.size() ==1 && token[0] == L'?') {
 bytes.push_back(0);
 mask.push_back(0x00);
 }
 token.clear();
 };
 for (size_t i = 0; i <= bytesStr.size(); ++i){ wchar_t c = (i < bytesStr.size()? bytesStr[i] : L' '); if (c == L' ' || c == L'\t' || c == L',' ) { pushTok(); } else token.push_back(c); }
 if (!bytes.empty()) { MemSigPattern p{}; p.name=name; p.bytes=std::move(bytes); p.mask=std::move(mask); p.weight = weight; pats.push_back(std::move(p)); }
 };
 for (size_t i = 0; i <= s.size(); ++i){ wchar_t c = (i < s.size()? s[i] : L';'); if (c == L';'){ flush(cur); cur.clear(); } else cur.push_back(c);}            
 MemorySignatureScanner mss; mss.SetThreshold(g_cfg.memorySignatureThreshold); mss.SetPatterns(pats);
 auto memPrefixes = g_cfg.memoryModuleWhitelistPrefixes.empty()? g_cfg.moduleWhitelistPrefixes : g_cfg.memoryModuleWhitelistPrefixes;
 mss.SetModuleWhitelistPrefixes(ParseWhitelistPrefixes(memPrefixes));
 mss.SetImagesOnly(g_cfg.memoryImagesOnly);
 MemorySignatureFinding mf{}; if (mss.RunOnceScan(mf)) {
 DetectionResult md{}; md.detected=true; md.pid=GetCurrentProcessId(); md.processName = mf.moduleName.empty()? L"<current>" : mf.moduleName; wchar_t addrbuf[32]; swprintf_s(addrbuf, L"0x%p", mf.address); md.reason = std::wstring(L"Memory signature hit: pattern='") + std::wstring(mf.patternName.begin(), mf.patternName.end()) + L"' at=" + addrbuf; md.indicatorCount=mf.indicators; if (md.indicatorCount >= g_cfg.memorySignatureThreshold) { ProcessDetection(md, "memsig"); fired=true; }
 }
 LogPerf(L"Periodic.MemorySignatureScanner", GetTickCount64()-t0);
 }
 return fired;
 };
 g_pPeriodic->Start(g_cfg.periodicScanIntervalMs);
}

static DWORD WINAPI InitThreadProc(LPVOID)
{
    LoadClientConfig(g_cfg, GetDllDirectory(g_hModule));
    ClampConfig();
    LogIfEnabled(L"[Oblivion] Init thread started\n");

    try {
        g_pNetClient = new NetworkClient();
        if (!g_pNetClient->Initialize(g_cfg.serverIp, g_cfg.serverPort)) {
            LogIfEnabled(L"[Oblivion] Network init failed\n");
        }
    } catch (...) {
        LogIfEnabled(L"[Oblivion] Exception during NetworkClient init\n");
        if (g_pNetClient) { delete g_pNetClient; g_pNetClient = nullptr; }
    }

    if (g_cfg.enableHmacAuth && !g_cfg.hmacSecret.empty()) {
        g_pNetClient->SetHmacSecret(g_cfg.hmacSecret);
    }

    if (g_cfg.enableHeartbeat) {
        try {
            g_pHeartbeat = new Heartbeat(g_pNetClient);
            g_pHeartbeat->Start(g_cfg.heartbeatIntervalMs);
        } catch (...) {
            g_pHeartbeat = nullptr;
        }
    }

    // Start kernel bridge (best-effort; will no-op if driver not present)
    if (g_cfg.enableKernelBridge) {
        KernelBridge_Start(g_pNetClient);
    }

    // Signature pack poller for fast YARA-like rollout (best-effort)
    try {
        g_pSigMgr = new SignaturePackManager(g_cfg.serverIp, g_cfg.serverPort, &g_cfg);
        g_pSigMgr->Start(60000); // poll every 60s
    } catch (...) {
        g_pSigMgr = nullptr;
    }

    // Start ETW-based heuristics with tunable window (use detectionCooldownMs as base window if set)
    try {
        DWORD etwWindowMs = g_cfg.detectionCooldownMs ? g_cfg.detectionCooldownMs / 2 : 3000; // default 3s window
        if (etwWindowMs < 500) etwWindowMs = 500; // clamp min
        g_pEtw = new EtwHeuristics(g_pNetClient, g_cfg.antiDebugThreshold, etwWindowMs);
        g_pEtw->Start();
    } catch (...) {
        g_pEtw = nullptr;
    }

    SchedulePeriodicScans();

    try {
        g_pWatcher = new ProcessThreadWatcher();
    } catch (...) {
        g_pWatcher = nullptr;
    }
    if (g_pWatcher && g_pWatcher->Initialize()) {
        g_pWatcher->SetCloseThreshold(g_cfg.closeThreshold);
        g_pWatcher->SetPollingIntervalMs(g_cfg.pollingIntervalMs);

        ULONGLONG t0 = GetTickCount64();
        DetectionResult result = g_pWatcher->RunOnceScan();
        LogPerf(L"ProcessThreadWatcher.FirstScan", GetTickCount64() - t0);
        if (result.detected && result.indicatorCount >= g_cfg.closeThreshold) {
            ProcessDetection(result, "process");
            CleanupGlobals();
            return 0;
        }

        if (g_cfg.enableOverlayScanner) {
            t0 = GetTickCount64();
            OverlayScanner overlay;
            int overlayThreshold = g_cfg.overlayThreshold > 0 ? g_cfg.overlayThreshold : 3;
            if (overlayThreshold < g_cfg.closeThreshold) overlayThreshold = g_cfg.closeThreshold;
            overlay.SetCloseThreshold(overlayThreshold);

            OverlayFinding of{};
            bool hit = overlay.RunOnceScan(of);
            LogPerf(L"OverlayScanner.RunOnceScan", GetTickCount64() - t0);
            if (hit) {
                DetectionResult od{};
                od.detected = true;
                od.pid = of.pid;
                od.processName = of.windowTitle.empty() ? of.className : of.windowTitle;
                od.reason = L"Suspicious overlay detected: title='" + od.processName + L"' class='" + of.className + L"'";
                od.indicatorCount = of.indicators;

                if (od.indicatorCount >= overlayThreshold) {
                    ProcessDetection(od, "overlay");
                    CleanupGlobals();
                    return 0;
                }
            }
        }

        if (g_cfg.enableAntiDebug) {
            t0 = GetTickCount64();
            AntiDebug ad; ad.SetThreshold(g_cfg.antiDebugThreshold);
            DetectionResult dbg{};
            bool hit = ad.RunScan(dbg);
            LogPerf(L"AntiDebug.RunScan", GetTickCount64() - t0);
            if (hit) {
                ProcessDetection(dbg, "antidebug");
                CleanupGlobals();
                return 0;
            }
        }

        if (g_cfg.enableInjectionScanner) {
            t0 = GetTickCount64();
            InjectionScanner inj; inj.SetThreshold(g_cfg.injectionThreshold);
            auto prefixes = ParseWhitelistPrefixes(g_cfg.moduleWhitelistPrefixes);
            inj.SetWhitelistPrefixes(prefixes);
            InjectionFinding inf{};
            bool hit = inj.RunOnceScan(inf);
            LogPerf(L"InjectionScanner.RunOnceScan", GetTickCount64() - t0);
            if (hit) {
                DetectionResult rd{};
                rd.detected = true;
                rd.pid = GetCurrentProcessId();
                rd.processName = inf.moduleName;
                rd.reason = L"Suspicious module injected: " + inf.modulePath;
                rd.indicatorCount = inf.indicators;

                if (rd.indicatorCount >= g_cfg.injectionThreshold) {
                    ProcessDetection(rd, "injection");
                    CleanupGlobals();
                    return 0;
                }
            }
        }

        if (g_cfg.enableSignatureValidator) {
            t0 = GetTickCount64();
            DigitalSignatureValidator dsv; dsv.SetThreshold(g_cfg.signatureThreshold);
            auto prefixes = ParseWhitelistPrefixes(g_cfg.moduleWhitelistPrefixes);
            dsv.SetWhitelistPrefixes(prefixes);
            dsv.SetSkipModuleNames(ParseWhitelistPrefixes(g_cfg.signatureSkipNames));
            SignatureFinding sf{};
            bool hit = dsv.RunOnceScan(sf);
            LogPerf(L"DigitalSignatureValidator.RunOnceScan", GetTickCount64() - t0);
            if (hit) {
                // Skip sigcheck for RRO.exe (hard guard) in addition to configured skip list
                if (!(IsRROExecutable(sf.moduleName) || IsRROExecutable(sf.modulePath))) {
                    DetectionResult sd{};
                    sd.detected = true;
                    sd.pid = GetCurrentProcessId();
                    sd.processName = sf.moduleName;
                    sd.reason = L"Untrusted signature or suspicious module: " + sf.modulePath;
                    sd.indicatorCount = sf.indicators;
                    if (sd.indicatorCount >= g_cfg.signatureThreshold) {
                        ProcessDetection(sd, "sigcheck");
                        CleanupGlobals();
                        return 0;
                    }
                }
            }
        }

        if (g_cfg.enableHijackedThreadScanner) {
            t0 = GetTickCount64();
            HijackedThreadScanner hts; hts.SetThreshold(g_cfg.hijackedThreadThreshold);
            auto prefixes = ParseWhitelistPrefixes(g_cfg.moduleWhitelistPrefixes);
            hts.SetWhitelistPrefixes(prefixes);
            HijackedThreadFinding hf{};
            bool hit = hts.RunOnceScan(hf);
            LogPerf(L"HijackedThreadScanner.RunOnceScan", GetTickCount64() - t0);
            if (hit) {
                DetectionResult td{};
                td.detected = true;
                td.pid = GetCurrentProcessId();
                wchar_t addrbuf[32]; swprintf_s(addrbuf, L"0x%p", hf.startAddress);
                td.processName = hf.moduleName.empty() ? L"<unknown>" : hf.moduleName;
                td.reason = std::wstring(L"Suspicious thread start: TID=") + std::to_wstring(hf.tid) + L", start=" + addrbuf + L", module=" + (hf.moduleName.empty() ? L"<unknown>" : hf.moduleName);
                td.indicatorCount = hf.indicators;
                if (td.indicatorCount >= g_cfg.hijackedThreadThreshold) {
                    ProcessDetection(td, "hijackedthread");
                    CleanupGlobals();
                    return 0;
                }
            }
        }

        if (g_cfg.enableIATHookScanner) {
            t0 = GetTickCount64();
            IATHookScanner iat; iat.SetThreshold(g_cfg.iatHookThreshold);
            auto prefixes = ParseWhitelistPrefixes(g_cfg.moduleWhitelistPrefixes);
            iat.SetWhitelistModules(prefixes);
            IATHookFinding f{};
            bool hit = iat.RunOnceScan(f);
            LogPerf(L"IATHookScanner.RunOnceScan", GetTickCount64() - t0);
            if (hit) {
                DetectionResult id{};
                id.detected = true;
                id.pid = GetCurrentProcessId();
                id.processName = f.moduleName.empty() ? L"<unknown>" : f.moduleName;
                wchar_t iatbuf[32]; swprintf_s(iatbuf, L"0x%p", f.iatAddress);
                wchar_t tgtbuf[32]; swprintf_s(tgtbuf, L"0x%p", f.targetAddress);
                id.reason = std::wstring(L"IAT hook: module=") + id.processName + L", import='" + std::wstring(f.importName.begin(), f.importName.end()) + L"', iat=" + iatbuf + L", target=" + tgtbuf + L", targetModule=" + (f.targetModule.empty() ? L"<unknown>" : f.targetModule);
                id.indicatorCount = f.indicators;
                if (id.indicatorCount >= g_cfg.iatHookThreshold) {
                    ProcessDetection(id, "iathook");
                    CleanupGlobals();
                    return 0;
                }
            }
        }

        // New: Code integrity scan (inline hook, RX/RWX regions, .text drift)
        {
            t0 = GetTickCount64();
            CodeIntegrityScanner cis; cis.SetThreshold(g_cfg.signatureThreshold); // reuse threshold
            cis.SetWhitelistPrefixes(ParseWhitelistPrefixes(g_cfg.moduleWhitelistPrefixes));
            DetectionResult ci{}; if (cis.RunOnceScan(ci)) { ProcessDetection(ci, "codeint"); CleanupGlobals(); return 0; }
            LogPerf(L"CodeIntegrityScanner.RunOnceScan", GetTickCount64() - t0);
        }

        if (g_cfg.enableFileIntegrityCheck && !g_cfg.integrityItems.empty()) {
            t0 = GetTickCount64();
            auto items = ParseIntegrityItems(GetDllDirectory(g_hModule), g_cfg.integrityItems);
            FileIntegrityChecker fic; fic.SetItems(items);
            IntegrityFinding fi{};
            bool hit = fic.RunOnceScan(fi);
            LogPerf(L"FileIntegrityChecker.RunOnceScan", GetTickCount64() - t0);
            if (hit) {
                DetectionResult ir{};
                ir.detected = true;
                ir.pid = GetCurrentProcessId();
                ir.processName = fi.path;
                std::wstring exp = fi.expectedHex.empty() ? L"<none>" : std::wstring(fi.expectedHex.begin(), fi.expectedHex.end());
                std::wstring act = fi.actualHex.empty() ? L"<none>" : std::wstring(fi.actualHex.begin(), fi.actualHex.end());
                ir.reason = L"Integrity mismatch: path='" + fi.path + L"' expected=" + exp + L" actual=" + act;
                ir.indicatorCount = fi.indicators;
                if (ir.indicatorCount >= 1) {
                    ProcessDetection(ir, "integrity");
                    CleanupGlobals();
                    return 0;
                }
            }
        }

        // Feature #6: Anti-Suspend heartbeat/watchdog
        if (g_cfg.enableAntiSuspend) {
            try {
                g_pAntiSuspend = new AntiSuspend();
                g_pAntiSuspend->Start(g_cfg.antiSuspendHeartbeatMs,
                                       g_cfg.antiSuspendStallWindowMs,
                                       g_cfg.antiSuspendMissesThreshold,
                                       AntiSuspendReportBridge);
            } catch (...) {
                g_pAntiSuspend = nullptr;
            }
        }

        if (g_cfg.enableBackgroundWatcher) {
            LogIfEnabled(L"[Oblivion] Starting background watcher\n");
            g_pWatcher->StartBackgroundWatcher();
        }
    }

    return 0;
}

static void CleanupGlobals()
{
    std::lock_guard<std::mutex> lock(g_cleanupMutex);
    // Stop background/periodic/etw/heartbeat before deleting
    if (g_pWatcher) { g_pWatcher->StopBackgroundWatcher(); delete g_pWatcher; g_pWatcher = nullptr; }
    if (g_pPeriodic) { g_pPeriodic->Stop(); delete g_pPeriodic; g_pPeriodic = nullptr; }
    if (g_pAntiSuspend) { g_pAntiSuspend->Stop(); delete g_pAntiSuspend; g_pAntiSuspend = nullptr; }
    if (g_pEtw) { g_pEtw->Stop(); delete g_pEtw; g_pEtw = nullptr; }
    if (g_pHeartbeat) { g_pHeartbeat->Stop(); delete g_pHeartbeat; g_pHeartbeat = nullptr; }
    if (g_pSigMgr) { g_pSigMgr->Stop(); delete g_pSigMgr; g_pSigMgr = nullptr; }
    if (g_cfg.enableKernelBridge) { KernelBridge_Stop(); }
    if (g_pNetClient) { delete g_pNetClient; g_pNetClient = nullptr; }
}

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID /*lpReserved*/
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
    {
        g_hModule = hModule;
        DisableThreadLibraryCalls(hModule);
        // Spawn lightweight init thread and return immediately to avoid loader-lock
        HANDLE hThread = CreateThread(nullptr, 0, InitThreadProc, nullptr, 0, nullptr);
        if (hThread) CloseHandle(hThread);
        break;
    }
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        break;
    case DLL_PROCESS_DETACH:
 {
 LogIfEnabled(L"[Oblivion] DLL_PROCESS_DETACH\n");
 CleanupGlobals();
 break;
 }
    }
    return TRUE;
}















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































